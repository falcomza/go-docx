# v2.1.0 Features Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add five new capabilities — package docs, chart introspection, table cell updates, and watermarks — without breaking the v2.x API.

**Architecture:** Each feature is additive. Reading features (`GetChartCount`, `GetChartData`) parse the extracted DOCX temp directory using the same patterns as the existing write path. `UpdateTableCell` does targeted XML string surgery on `document.xml`. `SetWatermark` injects a VML shape into the default header, creating one if needed. `doc.go` adds package-level godoc.

**Tech Stack:** Go 1.26, `encoding/xml`, `os`, `path/filepath`, `regexp`, `strings` — no new dependencies.

---

## Background

The library extracts a DOCX to a temp directory (`u.tempDir`), manipulates files directly, then repacks on `Save`. All source files are in the root package `godocx` (package path `github.com/falcomza/go-docx`). Chart XML lives in `word/charts/chart<N>.xml`. The document body is `word/document.xml`. Existing helper `detectNamespacePrefix(content string)` in `chart_xml.go` returns the namespace prefix (e.g. `"c"`) or `""` if none.

Tests that require `templates/docx_template.docx` skip automatically when the file is absent:
```go
if _, err := os.Stat(templatePath); os.IsNotExist(err) {
    t.Skip("Template file not found")
}
```
Run all tests: `go test ./... -v`

---

## Task 1: Package documentation (doc.go)

**Files:**
- Create: `doc.go`

No test needed — verified by `go doc github.com/falcomza/go-docx`.

**Step 1: Create doc.go**

```go
// Package godocx provides a programmatic API for creating and modifying
// Microsoft Word (DOCX) documents without requiring Microsoft Office.
//
// # Quick Start
//
//	u, err := godocx.New("template.docx")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer u.Cleanup()
//
//	u.UpdateChart(1, godocx.ChartData{
//	    Categories: []string{"Q1", "Q2", "Q3", "Q4"},
//	    Series: []godocx.SeriesData{
//	        {Name: "Revenue", Values: []float64{100, 150, 120, 180}},
//	    },
//	})
//
//	if err := u.Save("output.docx"); err != nil {
//	    log.Fatal(err)
//	}
//
// # Architecture
//
// go-docx extracts the DOCX ZIP archive to a temporary directory, manipulates
// the underlying OpenXML files directly, and repackages on [Updater.Save].
// Call [Updater.Cleanup] (typically via defer) to remove the temporary
// directory when done.
//
// # Inserting Content
//
// All Insert* and Add* methods accept an [InsertPosition]:
//   - [PositionEnd] — appends to the document body (default)
//   - [PositionBeginning] — prepends to the document body
//   - [PositionAfterText] — inserts after the paragraph containing Anchor text
//   - [PositionBeforeText] — inserts before the paragraph containing Anchor text
//
// # Chart Workflow
//
// Use [Updater.UpdateChart] to replace data in an existing chart template.
// Use [Updater.InsertChart] to create a new chart from scratch.
// Use [Updater.GetChartData] to read current chart categories and series.
package godocx
```

**Step 2: Verify godoc renders**

```bash
go doc github.com/falcomza/go-docx
```

Expected: package description and overview printed without errors.

**Step 3: Commit**

```bash
git add doc.go
git commit -m "docs: add package-level godoc in doc.go"
```

---

## Task 2: GetChartCount

**Files:**
- Modify: `chart_updater.go` (add method after `TempDir`)
- Test: `chart_updater_test.go` (add cases)

**Step 1: Write failing test**

In `chart_updater_test.go`, add:

```go
func TestGetChartCount(t *testing.T) {
    templatePath := filepath.Join("templates", "docx_template.docx")
    if _, err := os.Stat(templatePath); os.IsNotExist(err) {
        t.Skip("Template file not found")
    }

    u, err := New(templatePath)
    if err != nil {
        t.Fatalf("New: %v", err)
    }
    defer u.Cleanup()

    count, err := u.GetChartCount()
    if err != nil {
        t.Fatalf("GetChartCount: %v", err)
    }
    if count < 1 {
        t.Errorf("expected at least 1 chart, got %d", count)
    }
}

func TestGetChartCountEmpty(t *testing.T) {
    // Updater with no charts dir returns 0 without error
    u := &Updater{tempDir: t.TempDir()}
    count, err := u.GetChartCount()
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if count != 0 {
        t.Errorf("expected 0, got %d", count)
    }
}
```

**Step 2: Run to verify FAIL**

```bash
go test ./... -run TestGetChartCount -v
```

Expected: `undefined: (*Updater).GetChartCount`

**Step 3: Implement in chart_updater.go**

Add after the `TempDir` method (line ~56):

```go
// GetChartCount returns the number of charts embedded in the document.
// Returns 0 if the document contains no charts.
func (u *Updater) GetChartCount() (int, error) {
    if u == nil {
        return 0, errors.New("updater is nil")
    }
    chartsDir := filepath.Join(u.tempDir, "word", "charts")
    entries, err := os.ReadDir(chartsDir)
    if err != nil {
        if os.IsNotExist(err) {
            return 0, nil
        }
        return 0, fmt.Errorf("read charts dir: %w", err)
    }
    count := 0
    for _, e := range entries {
        name := e.Name()
        if !e.IsDir() && strings.HasPrefix(name, "chart") && strings.HasSuffix(name, ".xml") {
            count++
        }
    }
    return count, nil
}
```

**Step 4: Run to verify PASS**

```bash
go test ./... -run TestGetChartCount -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add chart_updater.go chart_updater_test.go
git commit -m "feat: add GetChartCount method"
```

---

## Task 3: GetChartData

**Files:**
- Modify: `chart_updater.go` (add public method)
- Create: `chart_read.go` (parsing logic, keeps chart_updater.go lean)
- Test: `chart_updater_test.go` (add cases)

`GetChartData` reads the chart XML and returns the categories, series names, and series values. It follows the same namespace-detection pattern used by `updateChartXMLContent` in `chart_xml.go`.

**Step 1: Write failing test**

```go
func TestGetChartData(t *testing.T) {
    templatePath := filepath.Join("templates", "docx_template.docx")
    if _, err := os.Stat(templatePath); os.IsNotExist(err) {
        t.Skip("Template file not found")
    }

    u, err := New(templatePath)
    if err != nil {
        t.Fatalf("New: %v", err)
    }
    defer u.Cleanup()

    data, err := u.GetChartData(1)
    if err != nil {
        t.Fatalf("GetChartData: %v", err)
    }
    if len(data.Categories) == 0 {
        t.Error("expected at least one category")
    }
    if len(data.Series) == 0 {
        t.Error("expected at least one series")
    }
    for i, s := range data.Series {
        if s.Name == "" {
            t.Errorf("series[%d] has empty name", i)
        }
        if len(s.Values) != len(data.Categories) {
            t.Errorf("series[%d]: %d values for %d categories", i, len(s.Values), len(data.Categories))
        }
    }
}

func TestGetChartDataInvalidIndex(t *testing.T) {
    templatePath := filepath.Join("templates", "docx_template.docx")
    if _, err := os.Stat(templatePath); os.IsNotExist(err) {
        t.Skip("Template file not found")
    }

    u, err := New(templatePath)
    if err != nil {
        t.Fatalf("New: %v", err)
    }
    defer u.Cleanup()

    _, err = u.GetChartData(0)
    if err == nil {
        t.Error("expected error for index 0")
    }
    _, err = u.GetChartData(999)
    if err == nil {
        t.Error("expected error for non-existent chart")
    }
}
```

**Step 2: Run to verify FAIL**

```bash
go test ./... -run TestGetChartData -v
```

Expected: `undefined: (*Updater).GetChartData`

**Step 3: Create chart_read.go**

```go
package godocx

import (
    "fmt"
    "os"
    "path/filepath"
    "regexp"
    "strconv"
    "strings"
)

// GetChartData reads the categories, series names, and values from chart N (1-based).
func (u *Updater) GetChartData(chartIndex int) (ChartData, error) {
    if u == nil {
        return ChartData{}, fmt.Errorf("updater is nil")
    }
    if chartIndex < 1 {
        return ChartData{}, fmt.Errorf("chart index must be >= 1")
    }
    chartPath := filepath.Join(u.tempDir, "word", "charts", fmt.Sprintf("chart%d.xml", chartIndex))
    raw, err := os.ReadFile(chartPath)
    if err != nil {
        return ChartData{}, fmt.Errorf("read chart%d.xml: %w", chartIndex, err)
    }
    return parseChartDataFromXML(raw)
}

// parseChartDataFromXML extracts ChartData from chart XML bytes.
// Uses the same namespace-detection pattern as updateChartXMLContent.
func parseChartDataFromXML(raw []byte) (ChartData, error) {
    content := string(raw)
    ns := detectNamespacePrefix(content)
    tag := func(t string) string {
        if ns == "" {
            return t
        }
        return ns + ":" + t
    }

    data := ChartData{}

    // Title: first <c:v> inside <c:tx> of the <c:title> block
    titleRe := regexp.MustCompile(`(?s)<` + regexp.QuoteMeta(tag("title")) + `[^>]*>.*?<` + regexp.QuoteMeta(tag("v")) + `[^>]*>(.*?)</`)
    if m := titleRe.FindStringSubmatch(content); m != nil {
        data.ChartTitle = strings.TrimSpace(m[1])
    }

    // Series: find all <c:ser> blocks
    serOpenTag := "<" + tag("ser") + ">"
    serCloseTag := "</" + tag("ser") + ">"
    serBlocks := extractBlocks(content, serOpenTag, serCloseTag)

    categories := extractCategoriesFromSer(serBlocks, tag)
    data.Categories = categories

    for _, block := range serBlocks {
        name := extractSeriesName(block, tag)
        values := extractSeriesValues(block, tag, len(categories))
        data.Series = append(data.Series, SeriesData{Name: name, Values: values})
    }

    return data, nil
}

// extractBlocks returns all substrings delimited by openTag..closeTag.
func extractBlocks(content, openTag, closeTag string) []string {
    var blocks []string
    for {
        start := strings.Index(content, openTag)
        if start < 0 {
            break
        }
        end := strings.Index(content[start:], closeTag)
        if end < 0 {
            break
        }
        end += start + len(closeTag)
        blocks = append(blocks, content[start:end])
        content = content[end:]
    }
    return blocks
}

// extractSeriesName returns the series name from a <c:ser> block.
// It reads the first <c:v> inside the <c:tx> element.
func extractSeriesName(block string, tag func(string) string) string {
    txClose := "</" + tag("tx") + ">"
    txEnd := strings.Index(block, txClose)
    if txEnd < 0 {
        return ""
    }
    txBlock := block[:txEnd]
    vRe := regexp.MustCompile(`<` + regexp.QuoteMeta(tag("v")) + `[^>]*>(.*?)</`)
    if m := vRe.FindStringSubmatch(txBlock); m != nil {
        return strings.TrimSpace(m[1])
    }
    return ""
}

// extractCategoriesFromSer reads category labels from the first series block.
func extractCategoriesFromSer(serBlocks []string, tag func(string) string) []string {
    if len(serBlocks) == 0 {
        return nil
    }
    catOpen := "<" + tag("cat") + ">"
    catClose := "</" + tag("cat") + ">"
    catStart := strings.Index(serBlocks[0], catOpen)
    catEnd := strings.Index(serBlocks[0], catClose)
    if catStart < 0 || catEnd < 0 {
        return nil
    }
    catBlock := serBlocks[0][catStart : catEnd+len(catClose)]
    vRe := regexp.MustCompile(`<` + regexp.QuoteMeta(tag("v")) + `[^>]*>(.*?)</`)
    matches := vRe.FindAllStringSubmatch(catBlock, -1)
    cats := make([]string, 0, len(matches))
    for _, m := range matches {
        cats = append(cats, strings.TrimSpace(m[1]))
    }
    return cats
}

// extractSeriesValues reads float64 values from a <c:ser> block's <c:val> element.
func extractSeriesValues(block string, tag func(string) string, count int) []float64 {
    valOpen := "<" + tag("val") + ">"
    valClose := "</" + tag("val") + ">"
    valStart := strings.Index(block, valOpen)
    valEnd := strings.Index(block, valClose)
    if valStart < 0 || valEnd < 0 {
        return make([]float64, count)
    }
    valBlock := block[valStart : valEnd+len(valClose)]
    vRe := regexp.MustCompile(`<` + regexp.QuoteMeta(tag("v")) + `[^>]*>(.*?)</`)
    matches := vRe.FindAllStringSubmatch(valBlock, -1)
    values := make([]float64, 0, len(matches))
    for _, m := range matches {
        f, err := strconv.ParseFloat(strings.TrimSpace(m[1]), 64)
        if err != nil {
            f = 0
        }
        values = append(values, f)
    }
    // Pad or trim to match category count
    for len(values) < count {
        values = append(values, 0)
    }
    return values[:count]
}
```

**Step 4: Run to verify PASS**

```bash
go test ./... -run TestGetChartData -v
```

Expected: PASS (or SKIP if template absent)

**Step 5: Commit**

```bash
git add chart_updater.go chart_read.go chart_updater_test.go
git commit -m "feat: add GetChartData to read existing chart categories and series"
```

---

## Task 4: UpdateTableCell

**Files:**
- Create: `table_update.go`
- Test: `table_test.go` (add cases at end of file)

`UpdateTableCell(tableIndex, row, col int, value string) error` modifies the text content of a single cell in an existing table. All indices are 1-based.

The approach: locate the Nth `<w:tbl>` block in `word/document.xml`, find the Rth `<w:tr>` within it, then the Cth `<w:tc>`, and replace the run text (`<w:t>`) with the new value.

**Step 1: Write failing test**

Add to `table_test.go`:

```go
func TestUpdateTableCell(t *testing.T) {
    templatePath := filepath.Join("templates", "docx_template.docx")
    if _, err := os.Stat(templatePath); os.IsNotExist(err) {
        t.Skip("Template file not found")
    }

    u, err := New(templatePath)
    if err != nil {
        t.Fatalf("New: %v", err)
    }
    defer u.Cleanup()

    // Insert a table so we have something to update
    err = u.InsertTable(TableOptions{
        Columns: []ColumnDefinition{
            {Title: "Name"},
            {Title: "Value"},
        },
        Rows: [][]string{
            {"Alpha", "100"},
            {"Beta", "200"},
        },
        Position: PositionEnd,
    })
    if err != nil {
        t.Fatalf("InsertTable: %v", err)
    }

    // Count tables — we'll update the last one
    tables, err := u.GetTableText()
    if err != nil {
        t.Fatalf("GetTableText: %v", err)
    }
    tableIdx := len(tables)

    // Update row 2, col 2 ("200" → "999")
    err = u.UpdateTableCell(tableIdx, 2, 2, "999")
    if err != nil {
        t.Fatalf("UpdateTableCell: %v", err)
    }

    // Verify
    tables2, err := u.GetTableText()
    if err != nil {
        t.Fatalf("GetTableText after update: %v", err)
    }
    got := tables2[tableIdx-1][2][1] // row 2 (index 2 after header), col 2 (index 1)
    if got != "999" {
        t.Errorf("expected '999', got %q", got)
    }
}

func TestUpdateTableCellValidation(t *testing.T) {
    u := &Updater{tempDir: t.TempDir()}
    // Create minimal document.xml
    docPath := filepath.Join(u.tempDir, "word")
    os.MkdirAll(docPath, 0o755)
    os.WriteFile(filepath.Join(docPath, "document.xml"), []byte(`<?xml version="1.0"?><w:document><w:body></w:body></w:document>`), 0o644)

    err := u.UpdateTableCell(0, 1, 1, "x")
    if err == nil {
        t.Error("expected error for tableIndex=0")
    }
    err = u.UpdateTableCell(1, 0, 1, "x")
    if err == nil {
        t.Error("expected error for row=0")
    }
    err = u.UpdateTableCell(1, 1, 0, "x")
    if err == nil {
        t.Error("expected error for col=0")
    }
    err = u.UpdateTableCell(1, 1, 1, "x") // no tables exist
    if err == nil {
        t.Error("expected error when no table at index 1")
    }
}
```

**Step 2: Run to verify FAIL**

```bash
go test ./... -run TestUpdateTableCell -v
```

Expected: `undefined: (*Updater).UpdateTableCell`

**Step 3: Create table_update.go**

```go
package godocx

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "xml/xml"  // use encoding/xml only for escaping
    "html"
)
```

Wait — use `html.EscapeString` from `html` package (already in stdlib) to escape the cell value. Or just do manual replacement of `<`, `>`, `&`.

```go
package godocx

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
)

// UpdateTableCell replaces the text content of a table cell.
// tableIndex, row, and col are all 1-based.
func (u *Updater) UpdateTableCell(tableIndex, row, col int, value string) error {
    if u == nil {
        return fmt.Errorf("updater is nil")
    }
    if tableIndex < 1 {
        return fmt.Errorf("tableIndex must be >= 1")
    }
    if row < 1 {
        return fmt.Errorf("row must be >= 1")
    }
    if col < 1 {
        return fmt.Errorf("col must be >= 1")
    }

    docPath := filepath.Join(u.tempDir, "word", "document.xml")
    raw, err := os.ReadFile(docPath)
    if err != nil {
        return fmt.Errorf("read document.xml: %w", err)
    }

    updated, err := updateTableCellContent(raw, tableIndex, row, col, value)
    if err != nil {
        return err
    }

    return os.WriteFile(docPath, updated, 0o644)
}

// updateTableCellContent performs the cell text replacement in document XML.
func updateTableCellContent(raw []byte, tableIndex, row, col int, value string) ([]byte, error) {
    content := string(raw)

    // Locate the Nth <w:tbl> block
    tblStart, tblEnd, err := findNthBlock(content, "<w:tbl>", "<w:tbl ", "</w:tbl>", tableIndex)
    if err != nil {
        return nil, fmt.Errorf("table %d: %w", tableIndex, err)
    }
    tblContent := content[tblStart:tblEnd]

    // Locate the Rth <w:tr> block within the table
    trStart, trEnd, err := findNthBlock(tblContent, "<w:tr>", "<w:tr ", "</w:tr>", row)
    if err != nil {
        return nil, fmt.Errorf("table %d row %d: %w", tableIndex, row, err)
    }
    trContent := tblContent[trStart:trEnd]

    // Locate the Cth <w:tc> block within the row
    tcStart, tcEnd, err := findNthBlock(trContent, "<w:tc>", "<w:tc ", "</w:tc>", col)
    if err != nil {
        return nil, fmt.Errorf("table %d row %d col %d: %w", tableIndex, row, col, err)
    }
    tcContent := trContent[tcStart:tcEnd]

    // Replace the <w:t> content, preserving xml:space if present
    updatedTC, err := replaceCellText(tcContent, value)
    if err != nil {
        return nil, fmt.Errorf("replace cell text: %w", err)
    }

    // Reassemble
    newTR := trContent[:tcStart] + updatedTC + trContent[tcEnd:]
    newTbl := tblContent[:trStart] + newTR + tblContent[trEnd:]
    result := content[:tblStart] + newTbl + content[tblEnd:]
    return []byte(result), nil
}

// findNthBlock locates the Nth occurrence of an element by trying both
// self-closing open tag variants (e.g. "<w:tbl>" and "<w:tbl ").
// Returns start and end byte offsets within content.
func findNthBlock(content, openTagExact, openTagAttr, closeTag string, n int) (int, int, error) {
    count := 0
    search := content
    offset := 0
    for {
        // Find next occurrence of either open tag form
        idxExact := strings.Index(search, openTagExact)
        idxAttr := strings.Index(search, openTagAttr)
        idx := -1
        switch {
        case idxExact >= 0 && idxAttr >= 0:
            if idxExact < idxAttr {
                idx = idxExact
            } else {
                idx = idxAttr
            }
        case idxExact >= 0:
            idx = idxExact
        case idxAttr >= 0:
            idx = idxAttr
        }
        if idx < 0 {
            return 0, 0, fmt.Errorf("not found: only %d element(s) exist", count)
        }
        count++
        absStart := offset + idx
        closeIdx := strings.Index(search[idx:], closeTag)
        if closeIdx < 0 {
            return 0, 0, fmt.Errorf("malformed XML: no closing tag %q", closeTag)
        }
        absEnd := absStart + closeIdx + len(closeTag)
        if count == n {
            return absStart, absEnd, nil
        }
        offset = absEnd
        search = content[offset:]
    }
}

// replaceCellText replaces all run text inside a <w:tc> block with value.
// Preserves the cell structure (properties, paragraph) but rewrites runs.
func replaceCellText(tcContent, value string) (string, error) {
    escaped := xmlEscapeString(value)

    // Find the paragraph <w:p> and replace its run content
    pOpen := "<w:p>"
    pOpenAttr := "<w:p "
    pClose := "</w:p>"

    pIdx := strings.Index(tcContent, pOpen)
    pIdxAttr := strings.Index(tcContent, pOpenAttr)

    var pStart int
    switch {
    case pIdx >= 0 && pIdxAttr >= 0:
        if pIdx < pIdxAttr {
            pStart = pIdx
        } else {
            pStart = pIdxAttr
        }
    case pIdx >= 0:
        pStart = pIdx
    case pIdxAttr >= 0:
        pStart = pIdxAttr
    default:
        return "", fmt.Errorf("no <w:p> found in cell")
    }

    pEnd := strings.Index(tcContent[pStart:], pClose)
    if pEnd < 0 {
        return "", fmt.Errorf("unclosed <w:p> in cell")
    }
    pEnd += pStart + len(pClose)
    pContent := tcContent[pStart:pEnd]

    // Preserve paragraph properties (w:pPr) if present
    pPr := ""
    pPrOpen := "<w:pPr>"
    pPrClose := "</w:pPr>"
    pPrStart := strings.Index(pContent, pPrOpen)
    if pPrStart >= 0 {
        pPrEnd := strings.Index(pContent[pPrStart:], pPrClose)
        if pPrEnd >= 0 {
            pPr = pContent[pPrStart : pPrStart+pPrEnd+len(pPrClose)]
        }
    }

    // Build a single clean run with the new value
    var newPContent strings.Builder
    newPContent.WriteString(pContent[:strings.Index(pContent, ">")+1]) // opening <w:p> tag
    if pPr != "" {
        newPContent.WriteString(pPr)
    }
    if escaped != "" {
        newPContent.WriteString(`<w:r><w:t xml:space="preserve">`)
        newPContent.WriteString(escaped)
        newPContent.WriteString(`</w:t></w:r>`)
    }
    newPContent.WriteString(pClose)

    return tcContent[:pStart] + newPContent.String() + tcContent[pEnd:], nil
}

// xmlEscapeString escapes special XML characters.
func xmlEscapeString(s string) string {
    s = strings.ReplaceAll(s, "&", "&amp;")
    s = strings.ReplaceAll(s, "<", "&lt;")
    s = strings.ReplaceAll(s, ">", "&gt;")
    s = strings.ReplaceAll(s, "\"", "&quot;")
    return s
}
```

**Step 4: Run to verify PASS**

```bash
go test ./... -run TestUpdateTableCell -v
```

Expected: PASS

**Step 5: Commit**

```bash
git add table_update.go table_test.go
git commit -m "feat: add UpdateTableCell for modifying existing table cells"
```

---

## Task 5: SetWatermark

**Files:**
- Create: `watermark.go`
- Test: `watermark_test.go`

A text watermark is a VML shape embedded in the default header of `sectPr`. If no default header exists, one is created. If one already exists, the watermark paragraph is prepended to it.

`WatermarkOptions`:
```go
type WatermarkOptions struct {
    Text     string // Required: watermark text (e.g. "CONFIDENTIAL", "DRAFT")
    Color    string // Hex color without # (default: "C0C0C0" — light grey)
    Angle    int    // Rotation in degrees, negative = counter-clockwise (default: -45)
    FontSize int    // Font size in pt (default: 72)
    Bold     bool   // Bold text (default: true)
}
```

**Step 1: Write failing test**

Create `watermark_test.go`:

```go
package godocx

import (
    "os"
    "path/filepath"
    "testing"
)

func TestSetWatermark(t *testing.T) {
    templatePath := filepath.Join("templates", "docx_template.docx")
    if _, err := os.Stat(templatePath); os.IsNotExist(err) {
        t.Skip("Template file not found")
    }

    u, err := New(templatePath)
    if err != nil {
        t.Fatalf("New: %v", err)
    }
    defer u.Cleanup()

    err = u.SetWatermark(WatermarkOptions{Text: "DRAFT"})
    if err != nil {
        t.Fatalf("SetWatermark: %v", err)
    }

    if err := u.Save(filepath.Join("outputs", "watermark_draft.docx")); err != nil {
        t.Fatalf("Save: %v", err)
    }
}

func TestSetWatermarkRequiresText(t *testing.T) {
    u := &Updater{tempDir: t.TempDir()}
    err := u.SetWatermark(WatermarkOptions{})
    if err == nil {
        t.Error("expected error for empty text")
    }
}

func TestSetWatermarkDefaults(t *testing.T) {
    opts := applyWatermarkDefaults(WatermarkOptions{Text: "TEST"})
    if opts.Color != "C0C0C0" {
        t.Errorf("expected default color C0C0C0, got %s", opts.Color)
    }
    if opts.Angle != -45 {
        t.Errorf("expected default angle -45, got %d", opts.Angle)
    }
    if opts.FontSize != 72 {
        t.Errorf("expected default font size 72, got %d", opts.FontSize)
    }
    if !opts.Bold {
        t.Error("expected bold to default to true")
    }
}

func TestGenerateWatermarkXML(t *testing.T) {
    opts := applyWatermarkDefaults(WatermarkOptions{Text: "CONFIDENTIAL"})
    xml := generateWatermarkParagraphXML(opts)
    xmlStr := string(xml)

    if !containsSubstr(xmlStr, "CONFIDENTIAL") {
        t.Error("watermark XML missing text")
    }
    if !containsSubstr(xmlStr, "v:shape") {
        t.Error("watermark XML missing v:shape")
    }
    if !containsSubstr(xmlStr, "v:textpath") {
        t.Error("watermark XML missing v:textpath")
    }
}

func containsSubstr(s, sub string) bool {
    return strings.Contains(s, sub)
}
```

**Step 2: Run to verify FAIL**

```bash
go test ./... -run TestSetWatermark -v
```

Expected: `undefined`

**Step 3: Create watermark.go**

```go
package godocx

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
)

// WatermarkOptions controls the appearance of a text watermark.
type WatermarkOptions struct {
    // Text is the watermark string, e.g. "DRAFT", "CONFIDENTIAL". Required.
    Text string

    // Color is a hex color code without '#' (default: "C0C0C0" — light grey).
    Color string

    // Angle is the rotation in degrees, negative = counter-clockwise (default: -45).
    Angle int

    // FontSize is the watermark font size in points (default: 72).
    FontSize int

    // Bold renders the watermark in bold (default: true).
    Bold bool
}

// SetWatermark adds a diagonal text watermark to every page by embedding a
// VML shape in the document's default header. If a default header already
// exists the watermark paragraph is prepended to it; otherwise a new header
// is created.
func (u *Updater) SetWatermark(opts WatermarkOptions) error {
    if u == nil {
        return fmt.Errorf("updater is nil")
    }
    if strings.TrimSpace(opts.Text) == "" {
        return fmt.Errorf("watermark text is required")
    }
    opts = applyWatermarkDefaults(opts)
    wmXML := generateWatermarkParagraphXML(opts)
    return u.injectWatermarkIntoHeader(wmXML)
}

// applyWatermarkDefaults fills zero-value fields with sensible defaults.
func applyWatermarkDefaults(opts WatermarkOptions) WatermarkOptions {
    if opts.Color == "" {
        opts.Color = "C0C0C0"
    }
    if opts.Angle == 0 {
        opts.Angle = -45
    }
    if opts.FontSize == 0 {
        opts.FontSize = 72
    }
    if !opts.Bold {
        opts.Bold = true
    }
    return opts
}

// generateWatermarkParagraphXML builds the VML watermark paragraph XML.
func generateWatermarkParagraphXML(opts WatermarkOptions) []byte {
    boldAttr := "bold"
    if !opts.Bold {
        boldAttr = "normal"
    }
    rotation := opts.Angle
    // Word expects mso-rotation in the style string
    style := fmt.Sprintf(
        "position:absolute;margin-left:0;margin-top:0;"+
            "width:527.85pt;height:263.9pt;z-index:-251654144;"+
            "mso-position-horizontal:center;mso-position-horizontal-relative:margin;"+
            "mso-position-vertical:center;mso-position-vertical-relative:margin;"+
            "mso-rotation:%d",
        rotation,
    )
    textpathStyle := fmt.Sprintf(
        `font-family:"Calibri";font-size:1pt;font-weight:%s`, boldAttr,
    )
    shapeID := "WaterMarkShape"
    xml := fmt.Sprintf(`<w:p>`+
        `<w:pPr><w:jc w:val="center"/></w:pPr>`+
        `<w:r>`+
        `<w:rPr><w:rStyle w:val="WatermarkText"/><w:color w:val="%s"/></w:rPr>`+
        `<w:pict>`+
        `<v:shape id="%s" type="#_x0000_t136" `+
        `style="%s" stroked="false" fillcolor="#%s" `+
        `xmlns:v="urn:schemas-microsoft-com:vml" `+
        `xmlns:o="urn:schemas-microsoft-com:office:office">`+
        `<v:textpath style='%s' string="%s" trim="t"/>`+
        `</v:shape>`+
        `</w:pict>`+
        `</w:r>`+
        `</w:p>`,
        opts.Color, shapeID, style, opts.Color, textpathStyle,
        xmlEscapeString(opts.Text),
    )
    return []byte(xml)
}

// injectWatermarkIntoHeader adds the watermark paragraph to the default header.
// Creates the header file if it does not exist.
func (u *Updater) injectWatermarkIntoHeader(wmXML []byte) error {
    headerFile := "header_watermark.xml"
    headerPath := filepath.Join(u.tempDir, "word", headerFile)

    // Build header XML with watermark paragraph
    headerXML := []byte(
        `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` +
            `<w:hdr xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" ` +
            `xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" ` +
            `xmlns:o="urn:schemas-microsoft-com:office:office" ` +
            `xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ` +
            `xmlns:v="urn:schemas-microsoft-com:vml" ` +
            `xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" ` +
            `xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" ` +
            `mc:Ignorable="w14">` +
            string(wmXML) +
            `<w:p><w:pPr><w:jc w:val="center"/></w:pPr></w:p>` +
            `</w:hdr>`,
    )

    if err := os.WriteFile(headerPath, headerXML, 0o644); err != nil {
        return fmt.Errorf("write watermark header: %w", err)
    }

    // Add relationship
    relID, err := u.addHeaderFooterRelationship(headerFile, "header")
    if err != nil {
        return fmt.Errorf("add header relationship: %w", err)
    }

    // Add content type
    if err := u.addHeaderFooterContentType(headerFile, "header"); err != nil {
        return fmt.Errorf("add header content type: %w", err)
    }

    // Link to sectPr as default header
    return u.updateDocumentForHeaderFooter("w:headerReference", "default", relID, false, false)
}
```

> **Note:** `addHeaderFooterRelationship`, `addHeaderFooterContentType`, and `updateDocumentForHeaderFooter` are existing unexported methods in `headerfooter.go`. Check their exact signatures before calling — the third parameter of `updateDocumentForHeaderFooter` is `relID string`.

**Step 4: Run to verify PASS**

```bash
go test ./... -run TestSetWatermark -v
```

Expected: PASS (template tests) or SKIP (no template)

**Step 5: Add watermark example**

Create `examples/example_watermark.go`:

```go
//go:build ignore

package main

import (
    "fmt"
    "log"

    updater "github.com/falcomza/go-docx"
)

func main() {
    u, err := updater.New("templates/docx_template.docx")
    if err != nil {
        log.Fatal(err)
    }
    defer u.Cleanup()

    if err := u.SetWatermark(updater.WatermarkOptions{
        Text:     "CONFIDENTIAL",
        Color:    "C0C0C0",
        Angle:    -45,
        FontSize: 72,
        Bold:     true,
    }); err != nil {
        log.Fatal(err)
    }

    if err := u.Save("outputs/watermark_output.docx"); err != nil {
        log.Fatal(err)
    }
    fmt.Println("Saved outputs/watermark_output.docx")
}
```

**Step 6: Build example and run tests**

```bash
go build -o /dev/null examples/example_watermark.go
go test ./... -v 2>&1 | grep -E "^(=== RUN|--- (PASS|FAIL|SKIP)|ok|FAIL)"
```

Expected: all PASS or SKIP

**Step 7: Commit**

```bash
git add watermark.go watermark_test.go examples/example_watermark.go
git commit -m "feat: add SetWatermark for diagonal text watermarks"
```

---

## Task 6: Tag v2.1.0

**Step 1: Final verification**

```bash
go test ./...
go vet ./...
for f in examples/*.go; do go build -o /dev/null "$f" 2>/dev/null || go build -o /dev/null "$f" ../; done
```

Expected: all PASS, no vet errors, all examples build.

**Step 2: Tag and push**

```bash
git tag v2.1.0
git push origin v2.1.0
```

---

## Appendix: v3.0.0 Breaking Change — Remove ChartOptions Compat Shims

Planned for v3.0.0. The following four fields in `ChartOptions` (`chart.go`) are marked "backward compat" and duplicate the structured option fields:

| Field to remove | Replacement |
|---|---|
| `CategoryAxisTitle string` | `CategoryAxis.Title` |
| `ValueAxisTitle string` | `ValueAxis.Title` |
| `ShowLegend bool` | `Legend.Show` |
| `LegendPosition string` | `Legend.Position` |

**Migration for callers:**

```go
// Before (v2.x)
ChartOptions{
    CategoryAxisTitle: "Month",
    ValueAxisTitle:    "Count",
    ShowLegend:        true,
    LegendPosition:    "b",
}

// After (v3.0.0)
ChartOptions{
    CategoryAxis: &godocx.AxisOptions{Title: "Month"},
    ValueAxis:    &godocx.AxisOptions{Title: "Count"},
    Legend:       &godocx.LegendOptions{Show: true, Position: "b"},
}
```

**Plan:**
1. Remove the four fields from `ChartOptions` in `chart.go`
2. Remove the compat logic in `applyChartDefaults` (~lines 197–224)
3. Update `README.md` examples
4. Bump module version to `v3` in `go.mod` and all import paths
5. Tag `v3.0.0`
